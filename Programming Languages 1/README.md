# ğŸ’» Programming Languages 1  

This repository contains solutions to exercises from **Programming Languages 1**, where we explored the fundamentals of different programming paradigms using **SML/NJ, Prolog, Java, Python, and C**.  

---

## ğŸ“š Course Overview  

The course focused on understanding how different types of programming languages approach problem-solving. We worked with:  

- ğŸ› ï¸ **Imperative Programming** â€“ Using **C** and **Java** to understand structured programming and object-oriented principles.  
- ğŸ”¢ **Functional Programming** â€“ Using **SML/NJ** to explore recursion, pattern matching, and immutable data structures.  
- ğŸ¤– **Logic Programming** â€“ Using **Prolog** to understand rule-based programming and backtracking.  
- ğŸ **Dynamic Programming** â€“ Using **Python** to work with high-level scripting and dynamic typing.  

Each set of exercises focused on applying these concepts in different ways, helping to bridge the gap between paradigms.  

---

## ğŸ”‘ Key Concepts Learned  

### 1ï¸âƒ£ **Imperative & Object-Oriented Programming (C & Java)**  
- Understanding **variables, loops, and conditionals**.  
- Implementing **data structures and algorithms**.  
- Exploring **object-oriented programming (OOP)** concepts like **classes, inheritance, and polymorphism**.  

### 2ï¸âƒ£ **Functional Programming (SML/NJ)**  
- Working with **higher-order functions** and **recursion**.  
- Understanding **immutable data structures** and **pattern matching**.  
- Using **type inference** to write concise, type-safe code.  

### 3ï¸âƒ£ **Logic Programming (Prolog)**  
- Defining **facts, rules, and queries** to model relationships.  
- Exploring **backtracking and unification** for automated problem-solving.  
- Applying **Prologâ€™s declarative nature** to solve logical problems.  

### 4ï¸âƒ£ **Dynamic Programming (Python)**  
- Working with **lists, dictionaries, and dynamic typing**.  
- Using **list comprehensions** and **functional constructs** like `map()` and `filter()`.  
- Writing **concise and readable code** for various problem-solving tasks.  

---

## ğŸ“‚ Repository Contents  

This repository is divided into three exercise sets, each covering different programming paradigms:  

### **Set 1 (C & SML/NJ)**  
- `fairseq.c` / `fairseq.sml` â€“ Sequence fairness checks.  
- `arrange.c` / `arrange.sml` â€“ Arranging elements based on conditions.  

### **Set 2 (Java, Prolog & SML/NJ)**  
- `arrange.java`  â€“ Different implementations of arrangement logic.  
- `grid.java` / `grid.prolog` â€“ Grid-based problem-solving.  
- `minbases.sml` â€“ Logical problem-solving with minimal bases.  

### **Set 3 (Python & SML/NJ)**  
- `fairseq.py`/ `minbases.py`/ `grid.py`  â€“ Reimplementing logic in Python.  
- `grid.sml` â€“ Grid-based tasks in functional programming.  

---

## ğŸš€ How to Use This Repository  

Each exercise exists in multiple languages, showcasing different approaches to the same problem. You can:  
- Compare **functional, imperative, logic, and dynamic paradigms**.  
- See how **different language features** affect problem-solving.  
- Understand **when and why to use each paradigm**.  

---

Feel free to explore the code and reach out if you have any questions! ğŸš€  
