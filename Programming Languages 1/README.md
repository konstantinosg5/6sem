# 💻 Programming Languages 1  

This repository contains solutions to exercises from **Programming Languages 1**, where we explored the fundamentals of different programming paradigms using **SML/NJ, Prolog, Java, Python, and C**.  

---

## 📚 Course Overview  

The course focused on understanding how different types of programming languages approach problem-solving. We worked with:  

- 🛠️ **Imperative Programming** – Using **C** and **Java** to understand structured programming and object-oriented principles.  
- 🔢 **Functional Programming** – Using **SML/NJ** to explore recursion, pattern matching, and immutable data structures.  
- 🤖 **Logic Programming** – Using **Prolog** to understand rule-based programming and backtracking.  
- 🐍 **Dynamic Programming** – Using **Python** to work with high-level scripting and dynamic typing.  

Each set of exercises focused on applying these concepts in different ways, helping to bridge the gap between paradigms.  

---

## 🔑 Key Concepts Learned  

### 1️⃣ **Imperative & Object-Oriented Programming (C & Java)**  
- Understanding **variables, loops, and conditionals**.  
- Implementing **data structures and algorithms**.  
- Exploring **object-oriented programming (OOP)** concepts like **classes, inheritance, and polymorphism**.  

### 2️⃣ **Functional Programming (SML/NJ)**  
- Working with **higher-order functions** and **recursion**.  
- Understanding **immutable data structures** and **pattern matching**.  
- Using **type inference** to write concise, type-safe code.  

### 3️⃣ **Logic Programming (Prolog)**  
- Defining **facts, rules, and queries** to model relationships.  
- Exploring **backtracking and unification** for automated problem-solving.  
- Applying **Prolog’s declarative nature** to solve logical problems.  

### 4️⃣ **Dynamic Programming (Python)**  
- Working with **lists, dictionaries, and dynamic typing**.  
- Using **list comprehensions** and **functional constructs** like `map()` and `filter()`.  
- Writing **concise and readable code** for various problem-solving tasks.  

---

## 📂 Repository Contents  

This repository is divided into three exercise sets, each covering different programming paradigms:  

### **Set 1 (C & SML/NJ)**  
- `fairseq.c` / `fairseq.sml` – Sequence fairness checks.  
- `arrange.c` / `arrange.sml` – Arranging elements based on conditions.  

### **Set 2 (Java, Prolog & SML/NJ)**  
- `arrange.java`  – Different implementations of arrangement logic.  
- `grid.java` / `grid.prolog` – Grid-based problem-solving.  
- `minbases.sml` – Logical problem-solving with minimal bases.  

### **Set 3 (Python & SML/NJ)**  
- `fairseq.py`/ `minbases.py`/ `grid.py`  – Reimplementing logic in Python.  
- `grid.sml` – Grid-based tasks in functional programming.  

---

## 🚀 How to Use This Repository  

Each exercise exists in multiple languages, showcasing different approaches to the same problem. You can:  
- Compare **functional, imperative, logic, and dynamic paradigms**.  
- See how **different language features** affect problem-solving.  
- Understand **when and why to use each paradigm**.  

---

Feel free to explore the code and reach out if you have any questions! 🚀  
